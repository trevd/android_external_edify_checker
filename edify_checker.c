/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/stat.h>
#include "edify/expr.h"
#include "edify_checker.h"
#include "builtins.h"
//#include "minzip/Zip.h"

// Generated by the makefile, this function defines the
// RegisterDeviceExtensions() function, which calls all the
// registration functions for device-specific extensions.
//#include "register.inc"

// Where in the package we expect to find the edify script to execute.
// (Note it's "updateR-script", not the older "update-script".)
#define SCRIPT_NAME "META-INF/com/google/android/updater-script"

struct selabel_handle *sehandle;

int main(int argc, char** argv) {
    // Various things log information to stdout or stderr more or less
    // at random.  The log file makes more sense if buffering is
    // turned off so things appear in the right order.
    //setbuf(stdout, NULL);
    //setbuf(stderr, NULL);
	fprintf(stdout,"edify syntax checker v0.1\n");
	if(argc < 2)
	{
		printf("\nUsage: %s updater-script\n", argv[0]);
		exit(1);
	}
	char* script_fn = argv[1];
	struct stat sb;
	FILE *script_fp = fopen(script_fn,"r"); 
	int script_fd = fileno(script_fp);
    //Check if open() was successful 
    if(-1 == script_fd) 
    { 
        printf("\n NULL File descriptor\n"); 
        return -1; 
    } 
 
    if (fstat(script_fd , &sb) == -1) {
	   perror("stat");
	   exit(EXIT_FAILURE);
    }
    printf("Opening Script File:%s\t",script_fn);
	printf("File size:%lld bytes\n",(long long) sb.st_size);
	char* script = malloc(sb.st_size+1);
	fread (script,1,sb.st_size,script_fp);
	fclose(script_fp);
	script[sb.st_size] = '\0';
	RegisterBuiltins();
    RegisterInstallFunctions();
    //RegisterDeviceExtensions();
    FinishRegistration();
	Expr* root;
    int error_count = 0;
    fprintf(stdout,"validating function names\n");
    yy_scan_string(script);
    int error = yyparse(&root, &error_count);
    if (error != 0 || error_count > 0) {
        fprintf(stderr, "%d parse errors\n", error_count);
        return 6;
    }
    fprintf(stdout,"validating function parameters\n");
    State state;
    state.cookie = NULL;
    state.script = script;
    state.errmsg = NULL;
    char* result = Evaluate(&state, root);
   
    if (result == NULL) {
        if (state.errmsg == NULL) {
            fprintf(stderr, "script aborted (no error message)\n");
            fprintf(stdout, "ui_print script aborted (no error message)\n");
        } else {
            fprintf(stderr, "script aborted: %s\n", state.errmsg);
            char* line = strtok(state.errmsg, "\n");
            //while (line) {
                //fprintf(stdout, "ui_print %s\n", line);
               // line = strtok(NULL, "\n");
          //  }
        }
        free(state.errmsg);
        return 7;
    } else {
        fprintf(stderr, "script result was [%s]\n", result);
        free(result);
    }

    free(script);
	return 0;
	
    //char* package_data = argv[3];
    //ZipArchive za;
    //int err;
    //err = mzOpenZipArchive(package_data, &za);
    //if (err != 0) {
    //    fprintf(stderr, "failed to open package %s: %s\n",
    //            package_data, strerror(err));
    //    return 3;
    //}

    //const ZipEntry* script_entry = mzFindZipEntry(&za, SCRIPT_NAME);
    //if (script_entry == NULL) {
    //    fprintf(stderr, "failed to find %s in %s\n", SCRIPT_NAME, package_data);
    //   return 4;
    //}

   // char* script = malloc(script_entry->uncompLen+1);
    //if (!mzReadZipEntry(&za, script_entry, script, script_entry->uncompLen)) {
    //    fprintf(stderr, "failed to read script from package\n");
     //   return 5;
   // }
    //script[script_entry->uncompLen] = '\0';

    // Configure edify's functions.

 

    // Parse the script.

    //Expr* root;
    //int error_count = 0;
    //yy_scan_string(script);
    //int 
    //error = yyparse(&root, &error_count);
    //if (error != 0 || error_count > 0) {
     //   fprintf(stderr, "%d parse errors\n", error_count);
       // return 6;
   // }

    
    

   

    // Evaluate the parsed script.

    /*UpdaterInfo updater_info;
    updater_info.cmd_pipe = cmd_pipe;
    updater_info.package_zip = &za;
    updater_info.version = atoi(version);

    State state;
    state.cookie = &updater_info;
    state.script = script;
    state.errmsg = NULL;

    char* result = Evaluate(&state, root);
    if (result == NULL) {
        if (state.errmsg == NULL) {
            fprintf(stderr, "script aborted (no error message)\n");
            fprintf(cmd_pipe, "ui_print script aborted (no error message)\n");
        } else {
            fprintf(stderr, "script aborted: %s\n", state.errmsg);
            char* line = strtok(state.errmsg, "\n");
            while (line) {
                fprintf(cmd_pipe, "ui_print %s\n", line);
                line = strtok(NULL, "\n");
            }
            fprintf(cmd_pipe, "ui_print\n");
        }
        free(state.errmsg);
        return 7;
    } else {
        fprintf(stderr, "script result was [%s]\n", result);
        free(result);
    }

    if (updater_info.package_zip) {
        mzCloseZipArchive(updater_info.package_zip);
    }
    free(script);
*/
    return 0;
}
